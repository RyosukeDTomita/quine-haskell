{
  "BSInteractWithSolve": {
    "scope": "haskell",
    "description": "(BS Version) Interact with solve function template.",
    "prefix": "BS.InteractWithSolve",
    "body": [
      "{-# LANGUAGE CPP #-}",
      "{-# LANGUAGE OverloadedStrings #-}",
      "",
      "-- {-# OPTIONS_GHC -DATCODER #-}",
      "import Data.ByteString (ByteString)",
      "import Data.ByteString.Char8 qualified as BS",
      "import Debug.Trace (traceShowId)",
      "",
      "#ifdef ATCODER",
      "debug :: Bool ; debug = False",
      "#else",
      "debug :: Bool ; debug = True",
      "#endif",
      "",
      "dbgId :: (Show a) => a -> a",
      "dbgId x",
      "  | debug = traceShowId x",
      "  | otherwise = x",
      "",
      "readInt :: BS.ByteString -> Int",
      "readInt bs =",
      "  case BS.readInt bs of",
      "    Just (x, _) -> x",
      "    Nothing -> error \"input is not integer\"",
      "",
      "solve :: [Int] -> [Int]",
      "solve xs = dbgId $ map (subtract 0) xs",
      "",
      "main :: IO ()",
      "main =",
      "  BS.interact $ \\inputs ->",
      "    let ls = BS.lines inputs",
      "        n = readInt $ head ls",
      "        xs = map readInt . BS.words $ ls !! 1 :: [Int]",
      "     in BS.unwords (map (BS.pack . show) (solve xs)) <> BS.pack \"\\n\""
    ]
  },
  "Interact2DIntMatrix": {
    "scope": "haskell",
    "prefix": "interact2d",
    "description": "Read a 2D matrix via interact with solve function.",
    "body": [
      "{-# LANGUAGE CPP #-}",
      "import Debug.Trace (traceShowId)",
      "",
      "-- {-# OPTIONS_GHC -DATCODER #-}",
      "#ifdef ATCODER",
      "debug :: Bool ; debug = False",
      "#else",
      "debug :: Bool ; debug = True",
      "#endif",
      "",
      "dbgId :: (Show a) => a -> a",
      "dbgId x",
      "  | debug = traceShowId x",
      "  | otherwise = x",
      "",
      "solve :: [[Int]] -> [[Int]]",
      "solve xss = dbgId $ map (map (subtract 0)) xss",
      "",
      "main :: IO ()",
      "main = interact $ \\inputs ->",
      "  let ls = lines inputs",
      "      [_, _] = map read . words $ head ls :: [Int]",
      "      intList2D = map (map read . words) $ drop 1 ls :: [[Int]]",
      "   in unlines . map (unwords . map show) $ solve intList2D"
    ]
  },
  "ArrowInteractPipeline": {
    "scope": "haskell",
    "prefix": "interactArrow",
    "description": "Interact pipeline using Control.Arrow with solve function.",
    "body": [
      "import Control.Arrow ((>>>))",
      "",
      "solve :: [Int] -> [Int]",
      "solve xs = xs",
      "",
      "main :: IO ()",
      "main =",
      "  interact $",
      "    words >>> map (read :: String -> Int) >>> solve >>> map show >>> unwords >>> (++ \"\\n\")"
    ]
  },
  "InteractWithSolve": {
    "scope": "haskell",
    "prefix": "interactSolve",
    "description": "Interact with solve function template.",
    "body": [
      "{-# LANGUAGE CPP #-}",
      "import Debug.Trace (traceShowId)",
      "",
      "-- {-# OPTIONS_GHC -DATCODER #-}",
      "#ifdef ATCODER",
      "debug :: Bool ; debug = False",
      "#else",
      "debug :: Bool ; debug = True",
      "#endif",
      "",
      "dbgId :: (Show a) => a -> a",
      "dbgId x",
      "  | debug = traceShowId x",
      "  | otherwise = x",
      "",
      "solve :: [Int] -> [Int]",
      "solve xs = dbgId $ map (subtract 0) xs",
      "",
      "main :: IO ()",
      "main =",
      "  interact $ \\inputs ->",
      "    let ls = lines inputs",
      "        n = (read :: String -> Int) $ head ls",
      "        xs = map read . words $ ls !! 1 :: [Int]",
      "     in unwords (map show (solve xs)) ++ \"\\n\""
    ]
  },
	"BS.interact2d": {
		"prefix": "BS.interact2d",
		"body": [
"{-# LANGUAGE CPP #-}",
"{-# LANGUAGE OverloadedStrings #-}",
"",
"-- {-# OPTIONS_GHC -DATCODER #-}",
"import Data.ByteString (ByteString)",
"import Data.ByteString.Char8 qualified as BS",
"import Debug.Trace (traceShowId)",
"",
"#ifdef ATCODER",
"debug :: Bool ; debug = False",
"#else",
"debug :: Bool ; debug = True",
"#endif",
"",
"dbgId :: (Show a) => a -> a",
"dbgId x",
"  | debug = traceShowId x",
"  | otherwise = x",
"",
"-- ByteStringç‰ˆ read",
"readInt :: BS.ByteString -> Int",
"readInt bs =",
"  case BS.readInt bs of",
"    Just (x, _) -> x",
"    Nothing -> error \"input is not integer\"",
"",
"solve :: [[Int]] -> [[Int]]",
"solve xss = dbgId $ map (map (subtract 0)) xss",
"",
"main :: IO ()",
"main = BS.interact $ \\inputs ->",
"  let ls = BS.lines inputs",
"      [_, _] = map readInt . BS.words $ head ls :: [Int]",
"      intList2D = map (map readInt . BS.words) $ drop 1 ls :: [[Int]]",
"   in BS.unlines . map (BS.unwords . map (BS.pack . show)) $ solve intList2D"
		],
		"description": "(BS version) Read a 2D matrix via interact with solve function"
	}
}
